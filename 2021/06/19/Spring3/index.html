<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gragaszz.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Spring 中的事件处理基础概念 Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。 那么，什么是事件? 事件是可以被控件识别的操作，比如我们按确定付款。每一种控件有自己可以识别的事件.     Spring就有控件。例如，当上下文启动时，ContextStart">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring3">
<meta property="og:url" content="https://gragaszz.github.io/2021/06/19/Spring3/index.html">
<meta property="og:site_name" content="看不见我">
<meta property="og:description" content="Spring 中的事件处理基础概念 Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。 那么，什么是事件? 事件是可以被控件识别的操作，比如我们按确定付款。每一种控件有自己可以识别的事件.     Spring就有控件。例如，当上下文启动时，ContextStart">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hualigs.cn/image/60d52f39504b7.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/60d53031b12a0.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/60d53b6395978.jpg">
<meta property="article:published_time" content="2021-06-19T11:32:47.000Z">
<meta property="article:modified_time" content="2021-06-25T05:05:59.702Z">
<meta property="article:author" content="Gragas">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hualigs.cn/image/60d52f39504b7.jpg">

<link rel="canonical" href="https://gragaszz.github.io/2021/06/19/Spring3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring3 | 看不见我</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">看不见我</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gragaszz.github.io/2021/06/19/Spring3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head-sculpture.jpg">
      <meta itemprop="name" content="Gragas">
      <meta itemprop="description" content="不要像水消失在水中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="看不见我">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-19 19:32:47" itemprop="dateCreated datePublished" datetime="2021-06-19T19:32:47+08:00">2021-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-25 13:05:59" itemprop="dateModified" datetime="2021-06-25T13:05:59+08:00">2021-06-25</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Spring-中的事件处理"><a href="#Spring-中的事件处理" class="headerlink" title="Spring 中的事件处理"></a>Spring 中的事件处理</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p> Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。</p>
<p>那么，什么是事件?</p>
<p>事件是可以被控件识别的操作，比如我们按确定付款。每一种控件有自己可以识别的事件.    </p>
<p>Spring就有控件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止时，ContextStoppedEvent 发布。</p>
<p><code>ApplicationContext</code>中的事件处理是通过<code>ApplicationEvent</code>类和<code>ApplicationListener</code>接口提供的。 </p>
<p>如果一个实现<code>ApplicationListener</code>接口的bean被部署到上下文中，则每当<code>ApplicationEvent</code>发布到ApplicationContext时，都会通知该bean。本质上，这是标准的观察者模式。</p>
<h2 id="Spring内置的事件"><a href="#Spring内置的事件" class="headerlink" title="Spring内置的事件"></a>Spring内置的事件</h2><h3 id="ContextRefreshedEvent"><a href="#ContextRefreshedEvent" class="headerlink" title="ContextRefreshedEvent"></a><strong>ContextRefreshedEvent</strong></h3><blockquote>
<p> 在<code>ApplicationContext</code>初始化或刷新时发布。</p>
</blockquote>
<p>例如，使用<code>ConfigurableApplicationContext</code>接口上的<code>refresh()</code>方法。 </p>
<p>这里的“初始化”意味着所有的bean都被加载，检测并激活后处理器bean，单例被预先实例化，并且<code>ApplicationContext</code>对象已经可以使用了。 </p>
<p>只要上下文没有关闭，只要所选的<code>ApplicationContex</code>t实际上支持这种“热”刷新，刷新可以被触发多次。 例如，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持。</p>
<h3 id="ContextStartedEvent"><a href="#ContextStartedEvent" class="headerlink" title="ContextStartedEvent"></a><strong>ContextStartedEvent</strong></h3><blockquote>
<p>在<code>ApplicationContext</code>启动时发布</p>
</blockquote>
<p>例如：使用<code>ConfigurableApplicationContext</code>接口上的<code>start()</code>方法时</p>
<p>这里的“开始”意味着所有的生命周期bean都会收到明确的启动信号。 通常，这个信号用于在显式停止后重新启动Bean，但也可以用于启动尚未配置为自动启动的组件，例如尚未启动的组件。</p>
<h3 id="ContextStoppedEvent"><a href="#ContextStoppedEvent" class="headerlink" title="ContextStoppedEvent"></a><strong>ContextStoppedEvent</strong></h3><blockquote>
<p>在<code>ApplicationContext</code>停止时发布</p>
</blockquote>
<p>例如：使用<code>ConfigurableApplicationContext</code>接口上的<code>stop()</code>方法时。</p>
<p>这里“停止”意味着所有生命周期的bean都会收到明确的停止信号。 停止的上下文可以通过<code>start()</code>调用重新启动。</p>
<h3 id="ContextClosedEvent"><a href="#ContextClosedEvent" class="headerlink" title="ContextClosedEvent"></a><strong>ContextClosedEvent</strong></h3><blockquote>
<p>在<code>ApplicationContext</code>关闭时发布</p>
</blockquote>
<p>例如：在<code>ConfigurableApplicationContext</code>接口上使用<code>close()</code>方法时.</p>
<p> 这里的“关闭”意味着所有的单例bean被销毁。 一个关闭的上下文到达其生命的尽头; 它不能刷新或重新启动。</p>
<h3 id="RequestHandledEvent"><a href="#RequestHandledEvent" class="headerlink" title="RequestHandledEvent"></a><strong>RequestHandledEvent</strong></h3><blockquote>
<p>一个Web特定的事件，告诉所有的bean一个HTTP请求已被处理。</p>
</blockquote>
<p>此事件在请求完成后发布。 此事件仅适用于使用Spring的<code>DispatcherServlet</code>的Web应用程序。</p>
<p>由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。</p>
<h2 id="Spring的自定义事件"><a href="#Spring的自定义事件" class="headerlink" title="Spring的自定义事件"></a>Spring的自定义事件</h2><p>如果要自定义一个事件发布以及响应结果的话，首先可以想一下需要的条件有哪些？</p>
<p>首先肯定是创建一个事件了，所以要继承<code>ApplicationEvent</code>接口，由于这个类必须定义一个默认的构造函数，它应该从 ApplicationEvent 类中继承的构造函数。</p>
<p>有了事件，那么对应就要将事件发布在程序中。所以设计一个类为了能够发布事件 并且让容器知道。</p>
<p>通常这是通过创建一个实现了ApplicationEventPublisherAware的类并将其注册为一个Spring bean来完成的。</p>
<p>在配置的时候，Spring容器会检测到对应的bean实现了<code>ApplicationEventPublisherAware</code>，并且会自动调用<code>setApplicationEventPublisher()</code>。</p>
<p>实际上，传入的参数将是Spring容器本身; 您只需通过ApplicationEventPublisher接口与应用程序上下文交互即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = publisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CustomEvent ce = <span class="keyword">new</span> CustomEvent(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//发布事件，并通过ApplicationEventPublisher调用publishEvent()方法</span></span><br><span class="line">        publisher.publishEvent(ce);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以，为什么前面容器能够实现内置的事件？</p>
</blockquote>
<blockquote>
<p>因为容器可以识别 bean 作为事件发布者，是因为它实现了 ApplicationEventPublisherAware 接口。</p>
</blockquote>
<p>然后事件被发布，被容器知道后。就得自定义对应的响应事件，这个事件就是实现监听器的功能，当监听到对应类的事件是就触发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventHandler</span>  <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;监听的事件类&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring框架的AOP"><a href="#Spring框架的AOP" class="headerlink" title="Spring框架的AOP"></a>Spring框架的AOP</h1><h2 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h2><p>Aspect-oriented Programming (AOP) ，按照文档的意思来说它就是面向方面的编程。对我来说，它相当于针对功能进行分解，有点类似流。比如一个登录功能，它能够对所有要访问这一功能的请求进行操作，筛选要进行额外操作的请求（Pointcut），并且定义额外操作(Advice)</p>
<blockquote>
<p>切面：相当于切点＋通知</p>
</blockquote>
<p>个人觉得，AOP就是类似一个拦截器的概念，对某一方面（功能）进行拦截后，围绕请求的整个周期进行自定义的设置。其实际上是基于动态代理的概念</p>
<p>引用文档中的一幅图来直观的表示</p>
<p><img src="https://www.hualigs.cn/image/60d52f39504b7.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pojo pojo = <span class="keyword">new</span> SimplePojo();</span><br><span class="line">        <span class="comment">// this is a direct method call on the &#x27;pojo&#x27; reference</span></span><br><span class="line">        pojo.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（如果您在对象引用上调用一个方法，该方法将直接在该对象引用上调用）</p>
<p><img src="https://www.hualigs.cn/image/60d53031b12a0.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());</span><br><span class="line">        factory.addInterface(Pojo.class);</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> RetryAdvice());</span><br><span class="line"></span><br><span class="line">        Pojo pojo = (Pojo) factory.getProxy();</span><br><span class="line">        <span class="comment">// this is a method call on the proxy!</span></span><br><span class="line">        pojo.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，main方法有一个对代理的引用。对该对象引用的方法调用是对代理的调用。因此，代理可以委托给所有与特定方法调用相关的拦截器(通知)。</p>
<p>讲个题外话：由图可以看到，拦截只会在外部引用时使用，当内部进行引用自己的话（自调用），就无法触发对应的事件了。一般来说解决办法就是修改代码，不调用自己。</p>
<p>最后，必须注意AspectJ没有这种自调用问题，因为它不是一个基于代理的AOP框架。（好牛，但我不知道原理）</p>
<p>所以接下来，打算先说说动态代理，然后在讲讲AOP在xml配置以及注解中的使用</p>
<h2 id="动态代理（略写）"><a href="#动态代理（略写）" class="headerlink" title="动态代理（略写）"></a>动态代理（略写）</h2><p>这个点我在之前javaweb学习拦截器的时候有了解过，这里就搬运我写过的一些笔记吧。具体的底层这里就不作描述，只了解大致的运行过程。</p>
<p>首先动态代理能分成两类:基于jdk的动态代理，基于cglib的动态代理</p>
<p><strong>动态代理（Proxy）</strong>：一般使用newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)返回代理类的一个实例。查看底层代码大抵知道它如何实现的：先对传入的 h进行判断 为空则抛出异常；随后调用方法getProxyClass0(loader, intfs)获得与指定类装载器和一组接口相关的代理类类型对象（这里生成的代理类是继承了Proxy，所以解释了为什么需要接口。因为JAVA是单继承，所以只能实现接口的方法），然后通过反射获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h)），最后生成代理类的实例对象并把InvocationHandler 的实例传给它的构造方法（前面产生了CLASS对象，这里是获取构造器创建对象，并将InvocationHandler 的实例传进入  cons.newInstance(new Object[]{h})）</p>
<p>InvocationHandler 接口</p>
<ul>
<li>其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</li>
<li>即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</li>
</ul>
<p>代理类实现接口的方法后，全都是通过handler中invoke实现的。然后将不同的方法封装在method，将方法的参数封装到参数。</p>
<p>简明一点，代理类相当于它按照接口的模板动态的产生了一个类实例化并且关联一个handler对象。并且实例对象每次调用方法都会转化为执行对应的invoke，将方法封装成对象。</p>
<p>在使用JDK动态代理的时候，即使这个接口没有任何的实现类，也可以根据这个接口，创建一个代理类，所以，可以说<strong>JDK动态代理关注的重点的接口</strong>，而不是实现了接口的具体实现类，这一点要清楚。</p>
<p>而基于cglib的动态代理是基于类进行创建代理类的：他会创建一个增强器new Enhancer()，然后设置对应的父类<code>setSuperclass</code>以及回调方法<code>setCallback</code>，最后设置代理对象：enhancer.create()。</p>
<blockquote>
<p>Spring是可以实现这两个代理情况，默认优先jdk</p>
</blockquote>
<h2 id="Spring-中基于-AOP-的-XML架构"><a href="#Spring-中基于-AOP-的-XML架构" class="headerlink" title="Spring 中基于 AOP 的 XML架构"></a>Spring 中基于 AOP 的 XML架构</h2><p>为了在本节的描述中使用 aop 命名空间标签，你需要导入 spring-aop j架构，如下所述：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop.xsd &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时要导入jar包，我用maven搭建了一个Springboot的demo，但好像还是需要自己导入这个aspectjweaver的依赖包。</p>
<p>这里简单说一下代理对象能在方法的哪些周期进行操作，就是我们说的通知工作（advice）</p>
<table>
<thead>
<tr>
<th align="left">通知</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前置通知</td>
<td align="left">在一个方法执行之前，执行通知。</td>
</tr>
<tr>
<td align="left">后置通知</td>
<td align="left">在一个方法执行之后，不考虑其结果，执行通知。</td>
</tr>
<tr>
<td align="left">返回后通知</td>
<td align="left">在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>
</tr>
<tr>
<td align="left">抛出异常后通知</td>
<td align="left">在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>
</tr>
<tr>
<td align="left">环绕通知</td>
<td align="left">在建议方法调用之前和之后，执行通知。</td>
</tr>
</tbody></table>
<p>之后开始编写xml的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明一个aspect，注入通知类的依赖--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logging&quot;</span>&gt;</span> </span><br><span class="line">       <span class="comment">&lt;!--声明一个切入点,指定要筛选的范围--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xxkt.Student.getName(..))&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--声明建议:在何时要进行方法的增强，方法的具体内容引用--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">method</span>=<span class="string">&quot;beforeAdvice&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">method</span>=<span class="string">&quot;afterAdvice&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logging&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxkt.Logging&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>基于配置的拦截方法现在知道的是这个样子的操作：<br>1、设置一个类用来设置拦截后要进行的方法加强:如logging类<br>2、编写一个类用来到时候调用方法后触发拦截，如student类<br>3、在配置中设置<a href="aop:config">aop:config</a><br>     3-1先设置对应的&lt;aop:aspect id=”..” ref=”…”&gt;ref表示要引用的拦截类<br>     3-2 配置对应的要拦截的范围&lt;aop:pointcut id=”selectAll” expression=”execution(* com.example.aspectDemo.*.*(..))”/&gt;<br>     3-3 配置对拦截后的类要进行什么样的操作（什么时候拦截，拦截后做什么）<br>          ，如：&lt;aop:around pointcut-ref=”businessService” method=”doRequiredTask”/&gt;</p>
<p>下面讲讲一些配置中的标签和对应的属性</p>
<p>&lt;aop:pointcut id=”…”  expression=”…”/&gt;定义切点</p>
<p>这个标签就是用来设置筛选范围的，id就是这个切点的名字，如果有通知需要该范围的话就用pointcut-ref引用。expression则是定义范围。</p>
<p><img src="https://www.hualigs.cn/image/60d53b6395978.jpg"></p>
<p>一般会用这些作为我们定义范围的语法，这里主要讲前几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution(修饰符类型 名字模式匹配类型（参数类型）)</span><br><span class="line">    execution(* set*(..))①</span><br><span class="line">    **execution**(* com.xyz.service.AccountService.*(..))②</span><br><span class="line">    execution(* com.xyz.service.*.*(..))③</span><br><span class="line">    execution(* com.xyz.service..*.*(..))④</span><br></pre></td></tr></table></figure>
<p>修饰符类型,指的是public，private这些 ，如果用 <code>*</code>，它代表了匹配任意的返回类型。 </p>
<p>名字模式匹配的是具体的classpath路径+方法名。 你可以使用<code>*</code>通配符作为所有或者部分命名模式。</p>
<p>比如上述例子</p>
<p>①表示任何一个以“set”开始的方法的执行</p>
<p>②表示AccountService 中的任意方法的执行</p>
<p>③表示定义在service包里的任意方法的执行：</p>
<p>④定义在service包或者子包里的任意方法的执行，相当于service.*.<em>.\</em>(..)</p>
<p> 参数模式稍微有点复杂：</p>
<p><code>()</code> 匹配了一个不接受任何参数的方法，</p>
<p>  <code>(..)</code> 匹配了一个接受任意数量参数的方法（零或者更多）。 </p>
<p>模式 <code>(*)</code> 匹配了一个接受一个任何类型的参数的方法。 </p>
<p>模式 <code>(*,String)</code> 匹配了一个接受两个参数的方法，第一个可以是任意类型，第二个则必须是<code>String</code>类型。 </p>
<p>还有就是在范围可以设置接收形参的名字，用args表示。一般用’and’,’or’,和’not’等对表达式进行合并筛选</p>
<p>接下来时对声明建议标签的描述了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span>/&gt;</span>前置通知</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span>/&gt;</span>通知在匹配的方法正常执行完后运行</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> /&gt;</span>通知在方法抛出异常退出时执行</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after</span>/&gt;</span>无论匹配的方法如何退出，After (finally) 通知都会在其退出后运行。</span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:around</span>/&gt;</span>环绕通知,环绕通知的运行保卫了匹配的方法执行。它可以在方法执行前，后执行，并决定了何时，如何，甚至根本不去执行方法</span><br></pre></td></tr></table></figure>
<p>其属性包括切点的范围和使用的方法.如果是对范围进行引用的话就是<strong>pointcut-ref</strong>，一般和前面的&lt;aop:pointcut id=”…”  expression=”…”/&gt;结合使用。如果自己定义的话，则用 pointcut。而定义使用方法则是用<strong>method</strong>。如果要接收参数或者返回值或者异常的话，则可以用arg-names和returning和throwing。前提是需要和形参的名称一样，同时对应范围要包括参数名。</p>
<p><strong>如果，同一方法有多个筛选器怎么办？</strong>实际上切面标签中有个order可以设置其优先级</p>
<h2 id="Spring-中基于-AOP-的-AspectJ"><a href="#Spring-中基于-AOP-的-AspectJ" class="headerlink" title="Spring 中基于 AOP 的@AspectJ"></a>Spring 中基于 AOP 的@AspectJ</h2><blockquote>
<p><code>@AspectJ</code> 作为通过 Java 5 注释注释的普通的 Java 类，它指的是声明 aspects 的一种风格。</p>
</blockquote>
<p>实际上如果要用这个风格的话，我们需要先启用对这个风格的支持：</p>
<p>在xml上定义**<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a>**</p>
<p>如果是通过java配置类的形式设置配置，则用 @Configuration 和 @EnableAspectJAutoProxy 注解</p>
<p>正如我们上面所说，这仅仅只是启用。如果要能被容器识别并配置，则需要使作为切面的类<strong>实例化</strong></p>
<p>具体的属性和标签其实和前面xml的一样，不过是使用方式不同，这里就直接给出对应的注解标签</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span><span class="comment">//定义在类上面，表示这是一个切面</span></span><br><span class="line"><span class="meta">@Pointcut</span><span class="comment">//设定要拦截的范围，作用在方法上 也可以在通知中用内联方式表示</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//方法名作为pointcut的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="meta">@Before(&quot;selectAll() &amp;&amp; args(a)&quot;)</span><span class="comment">//合并表达式，用&amp;&amp;这些</span></span><br><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;...&quot;, returning=&quot;...&quot;)</span></span><br><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;...&quot;, throwing = &quot;...&quot;)</span></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="meta">@Around</span></span><br><span class="line"><span class="comment">//默认值都是表示筛选范围，如果需要加入其他表示，则要加上前缀xx=xxx</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/19/Spring2/" rel="prev" title="Spring2">
      <i class="fa fa-chevron-left"></i> Spring2
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/26/Spring4/" rel="next" title="Spring4">
      Spring4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">Spring 中的事件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E5%86%85%E7%BD%AE%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">Spring内置的事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextRefreshedEvent"><span class="nav-number">1.2.1.</span> <span class="nav-text">ContextRefreshedEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextStartedEvent"><span class="nav-number">1.2.2.</span> <span class="nav-text">ContextStartedEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextStoppedEvent"><span class="nav-number">1.2.3.</span> <span class="nav-text">ContextStoppedEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextClosedEvent"><span class="nav-number">1.2.4.</span> <span class="nav-text">ContextClosedEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestHandledEvent"><span class="nav-number">1.2.5.</span> <span class="nav-text">RequestHandledEvent</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">Spring的自定义事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E7%9A%84AOP"><span class="nav-number">2.</span> <span class="nav-text">Spring框架的AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="nav-number">2.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E7%95%A5%E5%86%99%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">动态代理（略写）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%B8%AD%E5%9F%BA%E4%BA%8E-AOP-%E7%9A%84-XML%E6%9E%B6%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">Spring 中基于 AOP 的 XML架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%B8%AD%E5%9F%BA%E4%BA%8E-AOP-%E7%9A%84-AspectJ"><span class="nav-number">2.4.</span> <span class="nav-text">Spring 中基于 AOP 的@AspectJ</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gragas"
      src="/images/head-sculpture.jpg">
  <p class="site-author-name" itemprop="name">Gragas</p>
  <div class="site-description" itemprop="description">不要像水消失在水中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gragas</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
